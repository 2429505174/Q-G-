# QG训练营xx组第二周周记：

2021年4月8日

## 生活随记

博客：http://www.ruanyifeng.com/blog/2021/04/weekly-issue-152.html

[持续学习]: https://junglecoder.com/blog/learning-without-burnout

**但是，这个故事真正打动我的地方，不是他选择哪一条道路，而是他敢于去选择，不跟现状妥协。** 那一种自己把握命运的主动性和勇气，我不能这样过下去，这不是我要的路，我必须改变人生的方向，然后毅然决然付诸行动。

著名的美国科幻小说作家罗伯特·海因莱因（Robert A. Heinlein），给有志于写作的年轻人，传授过五条写作规则，帮助他们入门。

我觉得这些规则，不仅适用于作家，也同样适用于程序员。

**规则一：你必须动手写**

听起来很明显，是吗？但是，很多人只是想想而已，并没有真的动手写任何东西。成为作家的唯一途径是将自己放在键盘前，开始工作。

**规则二：完成草稿**

你开始写的前几页，可能很糟糕，你可能会想将它们扔掉。不要这样做，继续下去把草稿写完。一旦有了初稿，包括开头、中间和结尾，你会惊讶地发现，哪些是有用的部分，哪些是没用的部分。

**规则三：不要无休止地修改**

你应该不断修改你的草稿，但是一旦发现，修改后的效果没有比原来有太大的提升，就应该结束修改了。有句老话说，故事永远不会结束，只会被放弃。你要学习到了某个点，不再对这个作品投入时间。

**规则四：你必须将作品推向市场**

写完之后，放在书桌上是没有用的。即使你对自己没有信心，也应该把作品发布出去，看看外界的反应。不要胆怯，没有发表过的作品，等于没有写。

**规则五：你必须努力推广作品，直到售出为止**

一个事实是，你的作品几乎肯定会被拒绝，最大的可能是根本没有反响。不要为这种事情烦恼，很多伟大的作家都收过很多拒稿信。如果那些拒绝当中包含你认为不错的建议，请修改你的作品，然后再次发布。如果得不到什么建议，那就转向其他市场发布。你要坚持让更多的人看到你的作品。

最后，不管上一部作品得到什么样的成绩，你开始准备下一部作品。

取舍要学的东西

随着时间的推移保持学习速度

随着时间的推移保持学习速度

尝试找到乐趣，以及一个可持续的长期动机。寻找权衡，而不是教条。使用二进制搜索调试。倾听你的身体，对自己诚实

### PYTHON学习：



### 

#### python基础：

> 编码格式
>
> !/usr/bin/env python3
>
> -*- coding: utf-8 -*

1.  format()格式化输出

2. `f`开头的字符串，称之为`f-string`#自动代替变量

   

   1. #### 数据类型：

      list是一个可变的有序表

      list里面的元素的数据类型也可以不同

      list append insert pop

      只有1个元素的tuple定义时必须加一个逗号`,`，

      Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

      需要牢记的第一条就是dict的key必须是**不可变对象**。

      set add remove 

      字符串是不可变的 replace 对字符串操作，返回新的字符串，但是不改变原字符串。

       isinstance  数据类型检查可以用内置函数`isinstance()`

      在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值

      函数可以同时返回多个值，但其实就是一个tuple。

   2. ### 函数：

      ```python
      def calc(*numbers):#这里* 代表可以传入多个可变参数  无* 只能穿一个tuple or list and。。。
          sum = 0
          for n in numbers:
              sum = sum + n * n
          return sum
      num=(1,2,3,4)
      calc(*num) #这里* 可以将元祖变成多个可变参数传入
      ```

      

   3. 

   4. 




### 大组作业：

#### 链栈头指针问题 

初始化 申请空间为链栈头指针 

> 若这样：
>
> ```c
> LinkStackPtr stack;//= (LinkStackPtr)malloc(sizeof(StackNode)); 
> 
> ```
>
> 严重性	代码	说明	项目	文件	行	禁止显示状态
> 错误	C4700	使用了未初始化的局部变量“stack”	栈	D:\cnb\栈\LinkStack.c	68	
>
> 若这样：
>
> ```c
> //LinkStackPtr stack= (LinkStackPtr)malloc(sizeof(StackNode));
> ```
>
> 则初始化不成功。内存总是被释放。

#### 针对师兄提出的健壮性解答

##### **一亿：**

typedef int ElemType; 改动int 为 longlong int 

##### **1a 1aa  1， ：**

```c

if (ret == 1) {
     ch = getchar();
     if (ch == ' ' || ch == '\n') {

     }
 else {
     printf("||-->输入有异常!\n");
     while (getchar() != '\n');
     printf("||-->是否忽略(Y):");
     scanf("%c", &ch);
     if (ch == 'Y')
     {
                      //选择忽略后面的异常字符
     }
     else {
         ret = 0;  //重新循环 

     }
 }
```
加入这串代码 用选择是否忽略错误输入来解决问题。

#### 计算器问题：

##### 后缀表达式：

计算：

后缀表达式是从左向右“依次计算”，没有优先级的！

任一中缀表达式必然存在效果、意义相同的前缀、后缀表达式。

计算顺序就是：将后缀表达式从左到右依次遍历，如果当前元素为数字则**入（操作数）栈**，如果为操作符，则pop出栈顶两个元素（第一次pop出的是右操作数，第二次pop出的是左操作数）

**操作数栈**内理应只剩一个元素即表达式结果。

转换：（中缀转后缀）

从左到右开始扫描中缀表达式
遇到数字， 直接输出
遇到运算符
a.若为“(” 直接入栈
b.若为“)” 将符号栈中的元素依次出栈并输出, 直到 “(“, “(“只出栈, 不输出
c.**若为其他符号, 将符号栈中的元素依次出栈并输出, 直到遇到比当前符号优先级更低的符号或者”(“。** 将当前符号入栈。
扫描完后, 将栈中剩余符号依次输出

也就是遇到优先级高的入栈 优先级低的  则全部出栈



对中缀表达式进行求解依然是运用栈的技术。我们的计算器程序中使用了一个操作符栈用于转换，一个操作符数栈用于计算，而如果对中缀表达式进行求解则是同时利用操作数栈和操作符栈，

### 机器学习：

#### 简单线性回归：

$$
∑
$$

单元

计算真实值与预测值差：不用绝对值  因为 加绝对值不一定处处可导  后面用到导数。所以（y-y1）平方  称为 损失函数或效用函数   

最优化损失函数或者效用函数  损失最小 效用最大

所有参数模型，就是找到参数 最优化函数。

<img src="D:\nootbook\周记\zuixiao1.jpg" alt="zuixiao1" style="zoom: 33%;" /><img src="D:\nootbook\周记\zuixiao.jpg" alt="zuixiao"  />



SVM线性回归：

多项式回归：神经网络

逻辑回归：

**最优化原理** 学科

凸优化原理 

##### numpy 个别函数学习：

> ndim返回的是数组的维度，返回的只有一个数，该数即表示数组的维度。
>
> dtype：一个用于说明数组数据类型的对象。返回的是该数组的数据类型。
>
> d = np.array([[1,2],[3,4]],dtype=complex) # 指定数据类型  complex 复数类型

##### 矩阵转置方法：

> import numpy as np        
> a = np.array([1,2,3,4,5])
> print(a)
>
> 1.print(a.T) 不可  常用这个
> 2.print(a.transpose()) 不可 
> 3.print(a.reshape(a.shape[0],1)  可以用于一维矩阵

##### zip（）

> ﻿﻿zip()函数接受一系列可迭代对象作为参数，将不同对象中相对应的元素打包成一个元组（tuple），返回由这些元组组成的list列表，如果传入的参数的长度不等，则返回的list列表的长度和传入参数中最短对象的长度相同。
>
> zip相当与压缩 zip（*）相当于解压。

> ```python
> x=["a","1"]
> y=["b","2"]
> z = list(zip(x,y))
> print (list(zip(x,y)))
> print (list(zip(*z)))  解压
> 
> #[('a', 'b'), ('1', '2')]  
> 
> 
> 
> #[('a', '1'), ('b', '2')]
> ```

## 一周总结

这周学的东西比较离散，体会到了做笔记的好处。

自己听慕课敲代码模型，感觉确实不错。手推了第一个公式。



## 存在问题

###  isinstance  

> 这个函数的学习
>
> 
>
> ```python
> def my_abs(x):
>     if not isinstance(x, (int, float)):
>         raise TypeError('bad operand type')
>     if x >= 0:
>         return x
>     else:
>         return -x
> ```
>
> 如果 *classinfo* 是类型对象元组（或由其他此类元组递归组成的元组），那么如果 *object* 是其中任何一个类型的实例就返回 `True`。 如果 *classinfo* 既不是类型，也不是类型元组或类型元组的元组，则将引发 [`TypeError`](https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError) 异常。
>
> 解决！！！
>

### 头文件重复定义

> ifndef CALCULATE   //用于防止头文件被多次包含产生的多次定义问题
>
> define CALCULATE
>
>  ifndef #define #endif的用法总结：在头文件中出现了变量定义，这种情况下，这个#ifndef才有了作用，第一次被引用时，该定义能够同时被包含，但是第二次，由于已经define xxx了，所以这个定义就不能被重复包含了，这样就能有效的避免重复定义而报错了，因为编译过程中，声明可以，但是重复定义是不可以的。



### 系统数据类型命名：

typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;

size_t是一些C/C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。

为了增强程序的可移植性，便有了size_t，它是为了方便系统之间的移植而定义的，不同的系统上，定义size_t可能不一样。

```c
#include <stdio.h>
#include <string.h>
int main()
{
    int i = -1;
    if(i > strlen("Demon"))  //strlen返回值类型为size_t 
        printf("Hello World");
    else
        printf("Hello Demon");
    return 0;
}
```



即无符号的整型，而i的类型是int，即有符号的整型。当有符号整型和无符号整型进行运算时，有符号整型会先自动转化成无符号。-1转化成无符号数为4294967295，远远大于5。

**今后遇到有符号数和无符号数之间的运算时要千万小心。**

了解使用

### 缓冲区和标准输入（stdin）

fgets(input, sizeof(input) / sizeof(char), stdin); **stdin 模拟键盘输入文件读取**  大小表示  sizeof(input) / sizeof(char)  奇妙的方法 与我之前那个不太一样(查看文件属性 有字节数)

fgets(buf, STLEN, fp);
这里，buf是char类型数组的名称，STLEN是字符串的大小，**fp是指向 FILE的指针。**



### <ctype.h>

### 一个栈结构的不同数据类型储存问题

可以使用局部变量  相当于创建另一个局部栈和相关函数。

 

## 下周规划

继续python学习

数据库学习